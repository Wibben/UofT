
W:/ECE243/Lab5/Part4/part4.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__cs3_interrupt_vector>:
 * at a rate of 4Hz, pressing any key will stop/start the conter
 */
			.text
			.global _start
			
_start:		LDR		R9, =0xFFFEC600		// A9 private timer address
   0:	e59f90ec 	ldr	r9, [pc, #236]	; f4 <BIT_CODES+0xc>
			LDR		R4, =2000000		// 0.01 seconds on 200MHz clock
   4:	e59f40ec 	ldr	r4, [pc, #236]	; f8 <BIT_CODES+0x10>
			STR		R4, [R9]
   8:	e5894000 	str	r4, [r9]
			MOV		R4, #0b011			// Start timer and set it to auto-reload
   c:	e3a04003 	mov	r4, #3
			STR		R4, [R9, #0x8]
  10:	e5894008 	str	r4, [r9, #8]
			LDR		R6, =0xFF200020		// HEX3-HEX0 Address
  14:	e59f60e0 	ldr	r6, [pc, #224]	; fc <BIT_CODES+0x14>
			LDR 	R7, =0xFF200050		// KEY Address
  18:	e59f70e0 	ldr	r7, [pc, #224]	; 100 <BIT_CODES+0x18>
			MOV		R8, #BIT_CODES		// Address of BIT_CODES array
  1c:	e3a080e8 	mov	r8, #232	; 0xe8
			MOV		R2, #0				// R2 will be the counter
  20:	e3a02000 	mov	r2, #0
			MOV		R3, #1				// R3 will determine whether to count or not
  24:	e3a03001 	mov	r3, #1

00000028 <MAIN>:
MAIN:		LDRB	R5, [R7, #0xC]		// Read Edgecapture register
  28:	e5d7500c 	ldrb	r5, [r7, #12]
			CMP		R5, #0
  2c:	e3550000 	cmp	r5, #0
			BEQ		DELAY				// If Edgecapture is not 0 the a key has been pressed
  30:	0a000006 	beq	50 <DELAY>

00000034 <WAIT>:
WAIT:		LDR		R5, [R7]			// Poll KEYs to see if the KEY has been released
  34:	e5975000 	ldr	r5, [r7]
			CMP		R5, #0
  38:	e3550000 	cmp	r5, #0
			BNE		WAIT				// Wait for KEY to be released	
  3c:	1afffffc 	bne	34 <WAIT>
			MOV		R5, #0xF			// Reset Edgecapture
  40:	e3a0500f 	mov	r5, #15
			STR		R5, [R7, #0xC]
  44:	e587500c 	str	r5, [r7, #12]
			MOV		R4, #1
  48:	e3a04001 	mov	r4, #1
			SUB		R3, R4, R3			// Subtract R3 from 1 to invert it (1 <-> 0)
  4c:	e0443003 	sub	r3, r4, r3

00000050 <DELAY>:
			
DELAY:		LDR		R4, [R9, #0xC]		// Load timer interrupt flag
  50:	e599400c 	ldr	r4, [r9, #12]
			CMP		R4, #0				// Keep on delaying until interrupt flag is 1
  54:	e3540000 	cmp	r4, #0
			BEQ		DELAY
  58:	0afffffc 	beq	50 <DELAY>
			STR		R4, [R9, #0xC]		// Reset interrupt flag
  5c:	e589400c 	str	r4, [r9, #12]
			
			CMP		R3, #1				// When R3 = 1, increment counter
  60:	e3530001 	cmp	r3, #1
			BNE		DISPLAY
  64:	1a000004 	bne	7c <DISPLAY>
			ADD		R2, #1
  68:	e2822001 	add	r2, r2, #1
			LDR		R4, =6000			// Load a literal
  6c:	e59f4090 	ldr	r4, [pc, #144]	; 104 <BIT_CODES+0x1c>
			CMP		R2, R4				// Wrap around to 0 when R2 > 5999
  70:	e1520004 	cmp	r2, r4
			BNE		DISPLAY
  74:	1a000000 	bne	7c <DISPLAY>
			MOV		R2, #0
  78:	e3a02000 	mov	r2, #0

0000007c <DISPLAY>:
			
DISPLAY:	MOV		R0, R2				// Separate R2 into its digits
  7c:	e1a00002 	mov	r0, r2
			BL		DIVIDE
  80:	eb00000f 	bl	c4 <DIVIDE>
			LDRB	R4, [R8, +R0]		// Get pattern for ones digit
  84:	e7d84000 	ldrb	r4, [r8, r0]
			
			MOV		R0,	R1				// Get tens digit
  88:	e1a00001 	mov	r0, r1
			BL		DIVIDE
  8c:	eb00000c 	bl	c4 <DIVIDE>
			LDRB	R0, [R8, +R0]		// Get pattern for tens digit
  90:	e7d80000 	ldrb	r0, [r8, r0]
			LSL		R0, #8
  94:	e1a00400 	lsl	r0, r0, #8
			ORR		R4, R0
  98:	e1844000 	orr	r4, r4, r0
			
			MOV		R0, R1				// Get hundredth digit
  9c:	e1a00001 	mov	r0, r1
			BL		DIVIDE				// Remainder from divide is thousandth digit
  a0:	eb000007 	bl	c4 <DIVIDE>
			LDRB	R0, [R8, +R0]		// Get pattern for hundreds digit
  a4:	e7d80000 	ldrb	r0, [r8, r0]
			LSL		R0, #16
  a8:	e1a00800 	lsl	r0, r0, #16
			ORR		R4, R0
  ac:	e1844000 	orr	r4, r4, r0
			LDRB	R1, [R8, +R1]		// Get pattern for thousandth digit
  b0:	e7d81001 	ldrb	r1, [r8, r1]
			LSL		R1, #24
  b4:	e1a01c01 	lsl	r1, r1, #24
			ORR		R4, R1
  b8:	e1844001 	orr	r4, r4, r1
			
			STR		R4, [R6]			// Display counter
  bc:	e5864000 	str	r4, [r6]
			B		MAIN				// Program infinitely counts/loops
  c0:	eaffffd8 	b	28 <MAIN>

000000c4 <DIVIDE>:
			

/* Subroutine to perform the integer division R0 / 10.
 * Returns quotient in R1 and remainder in R0
 */
DIVIDE:     PUSH	{R2,LR}
  c4:	e92d4004 	push	{r2, lr}
			MOV     R2, #0
  c8:	e3a02000 	mov	r2, #0

000000cc <CONT>:
CONT:       CMP     R0, #10
  cc:	e350000a 	cmp	r0, #10
            BLT     DIV_END
  d0:	ba000002 	blt	e0 <DIV_END>
            SUB     R0, #10
  d4:	e240000a 	sub	r0, r0, #10
            ADD     R2, #1
  d8:	e2822001 	add	r2, r2, #1
            B       CONT
  dc:	eafffffa 	b	cc <CONT>

000000e0 <DIV_END>:
DIV_END:    MOV     R1, R2     		// quotient in R1 (remainder in R0)
  e0:	e1a01002 	mov	r1, r2
            POP     {R2,PC}
  e4:	e8bd8004 	pop	{r2, pc}

000000e8 <BIT_CODES>:
  e8:	4f5b063f 	.word	0x4f5b063f
  ec:	077d6d66 	.word	0x077d6d66
  f0:	0000677f 	.word	0x0000677f
  f4:	fffec600 	.word	0xfffec600
  f8:	001e8480 	.word	0x001e8480
  fc:	ff200020 	.word	0xff200020
 100:	ff200050 	.word	0xff200050
 104:	00001770 	.word	0x00001770
