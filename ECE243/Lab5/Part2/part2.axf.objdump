
W:/ECE243/Lab5/Part2/part2.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <__cs3_interrupt_vector>:
 * at a rate of 4Hz, pressing any key will stop/start the conter
 */
			.text
			.global _start
			
_start:		LDR		R6, =0xFF200020		// HEX3-HEX0 Address
   0:	e59f60a8 	ldr	r6, [pc, #168]	; b0 <BIT_CODES+0xc>
			LDR 	R7, =0xFF200050		// KEY Address
   4:	e59f70a8 	ldr	r7, [pc, #168]	; b4 <BIT_CODES+0x10>
			MOV		R8, #BIT_CODES		// Address of BIT_CODES array
   8:	e3a080a4 	mov	r8, #164	; 0xa4
			MOV		R2, #0				// R2 will be the counter
   c:	e3a02000 	mov	r2, #0
			MOV		R3, #1				// R3 will determine whether to count or not
  10:	e3a03001 	mov	r3, #1

00000014 <MAIN>:
MAIN:		LDRB	R5, [R7, #0xC]		// Read Edgecapture register
  14:	e5d7500c 	ldrb	r5, [r7, #12]
			CMP		R5, #0
  18:	e3550000 	cmp	r5, #0
			BEQ		DO_DELAY			// If Edgecapture is not 0 the a key has been pressed
  1c:	0a000006 	beq	3c <DO_DELAY>

00000020 <WAIT>:
WAIT:		LDR		R5, [R7]			// Poll KEYs to see if the KEY has been released
  20:	e5975000 	ldr	r5, [r7]
			CMP		R5, #0
  24:	e3550000 	cmp	r5, #0
			BNE		WAIT				// Wait for KEY to be released	
  28:	1afffffc 	bne	20 <WAIT>
			MOV		R5, #0xF			// Reset Edgecapture
  2c:	e3a0500f 	mov	r5, #15
			STR		R5, [R7, #0xC]
  30:	e587500c 	str	r5, [r7, #12]
			MOV		R4, #1
  34:	e3a04001 	mov	r4, #1
			SUB		R3, R4, R3			// Subtract R3 from 1 to invert it (1 <-> 0)
  38:	e0443003 	sub	r3, r4, r3

0000003c <DO_DELAY>:
			
DO_DELAY:	LDR		R4, =200000000		// Delay counter
  3c:	e59f4074 	ldr	r4, [pc, #116]	; b8 <BIT_CODES+0x14>

00000040 <SUB_LOOP>:
SUB_LOOP:	SUBS	R4, #1
  40:	e2544001 	subs	r4, r4, #1
			BNE		SUB_LOOP
  44:	1afffffd 	bne	40 <SUB_LOOP>
			
			CMP		R3, #1				// When R3 = 1, increment counter
  48:	e3530001 	cmp	r3, #1
			BNE		DISPLAY
  4c:	1a000003 	bne	60 <DISPLAY>
			ADD		R2, #1
  50:	e2822001 	add	r2, r2, #1
			CMP		R2, #100			// Wrap around to 0 when R2 > 99
  54:	e3520064 	cmp	r2, #100	; 0x64
			BNE		DISPLAY
  58:	1a000000 	bne	60 <DISPLAY>
			MOV		R2, #0
  5c:	e3a02000 	mov	r2, #0

00000060 <DISPLAY>:
			
DISPLAY:	MOV		R0, R2				// Separate R2 into its digits
  60:	e1a00002 	mov	r0, r2
			BL		DIVIDE
  64:	eb000005 	bl	80 <DIVIDE>
			LDRB	R0, [R8, +R0]		// Get pattern for ones digit
  68:	e7d80000 	ldrb	r0, [r8, r0]
			LDRB	R1, [R8, +R1]		// Get pattern for ones digit
  6c:	e7d81001 	ldrb	r1, [r8, r1]
			LSL		R1, #8
  70:	e1a01401 	lsl	r1, r1, #8
			ORR		R0, R1				// Put pattern in the same reg as the tens digit
  74:	e1800001 	orr	r0, r0, r1
			STR		R0, [R6]			// Display counter
  78:	e5860000 	str	r0, [r6]
			B		MAIN				// Program infinitely counts/loops
  7c:	eaffffe4 	b	14 <MAIN>

00000080 <DIVIDE>:
			

/* Subroutine to perform the integer division R0 / 10.
 * Returns quotient in R1 and remainder in R0
 */
DIVIDE:     PUSH	{R2,LR}
  80:	e92d4004 	push	{r2, lr}
			MOV     R2, #0
  84:	e3a02000 	mov	r2, #0

00000088 <CONT>:
CONT:       CMP     R0, #10
  88:	e350000a 	cmp	r0, #10
            BLT     DIV_END
  8c:	ba000002 	blt	9c <DIV_END>
            SUB     R0, #10
  90:	e240000a 	sub	r0, r0, #10
            ADD     R2, #1
  94:	e2822001 	add	r2, r2, #1
            B       CONT
  98:	eafffffa 	b	88 <CONT>

0000009c <DIV_END>:
DIV_END:    MOV     R1, R2     		// quotient in R1 (remainder in R0)
  9c:	e1a01002 	mov	r1, r2
            POP     {R2,PC}
  a0:	e8bd8004 	pop	{r2, pc}

000000a4 <BIT_CODES>:
  a4:	4f5b063f 	.word	0x4f5b063f
  a8:	077d6d66 	.word	0x077d6d66
  ac:	0000677f 	.word	0x0000677f
  b0:	ff200020 	.word	0xff200020
  b4:	ff200050 	.word	0xff200050
  b8:	0bebc200 	.word	0x0bebc200
