
W:/ECE243/Lab6/Part4/part4.axf:     file format elf32-littlearm


Disassembly of section .vectors:

00000000 <__cs3_interrupt_vector>:
   0:	ea00000e 	b	40 <__cs3_region_init_ram>
   4:	ea0000dc 	b	37c <SERVICE_UND>
   8:	ea0000dc 	b	380 <SERVICE_SVC>
   c:	ea0000dd 	b	388 <SERVICE_ABT_INST>
  10:	ea0000db 	b	384 <SERVICE_ABT_DATA>
  14:	00000000 	.word	0x00000000
  18:	ea00002d 	b	d4 <SERVICE_IRQ>
  1c:	ea0000da 	b	38c <SERVICE_FIQ>

Disassembly of section .text:

00000040 <__cs3_region_start_ram>:
				B       SERVICE_FIQ			// FIQ interrupt vector
				.text
				.global _start                        
_start:                                         
/* Set up stack pointers for IRQ and SVC processor modes */
                MOV     R1, #0b11010010		// interrupts masked, MODE = IRQ
  40:	e3a010d2 	mov	r1, #210	; 0xd2
				MSR		CPSR_c, R1			// change to IRQ mode
  44:	e121f001 	msr	CPSR_c, r1
				LDR		SP, =0xFFFFFFFF - 3	// set IRQ stack to A9 onchip memory
  48:	e3e0d003 	mvn	sp, #3

				MOV     R1, #0b11010011		// interrupts masked, MODE = SVC
  4c:	e3a010d3 	mov	r1, #211	; 0xd3
				MSR     CPSR, R1			// change to supervisor mode
  50:	e129f001 	msr	CPSR_fc, r1
				LDR		SP, =0x3FFFFFFF - 3	// set SVC stack to top of DDR3 memory
  54:	e3e0d10f 	mvn	sp, #-1073741821	; 0xc0000003

                BL      CONFIG_GIC       	// configure the ARM generic interrupt controller
  58:	eb00009e 	bl	2d8 <CONFIG_GIC>
				BL		CONFIG_PRIV_TIMER   // configure the private timer
  5c:	eb00000a 	bl	8c <CONFIG_PRIV_TIMER>
                BL      CONFIG_TIMER     	// configure the Interval Timer
  60:	eb00000f 	bl	a4 <CONFIG_TIMER>
                BL      CONFIG_KEYS      	// configure the pushbutton KEYs port
  64:	eb000016 	bl	c4 <CONFIG_KEYS>

/* Enable IRQ interrupts in the ARM processor */
                MOV      R0, #0b01010011	// IRQ unmasked, MODE = SVC
  68:	e3a00053 	mov	r0, #83	; 0x53
				MSR      CPSR_c, R0
  6c:	e121f000 	msr	CPSR_c, r0
				
                LDR     R5, =0xFF200000     // LEDR base address
  70:	e59f523c 	ldr	r5, [pc, #572]	; 2b4 <BIT_CODE+0xc>
                LDR     R6, =0xFF200020     // HEX3-0 base address
  74:	e59f623c 	ldr	r6, [pc, #572]	; 2b8 <BIT_CODE+0x10>

00000078 <LOOP>:
LOOP:                                           
                LDR     R4, COUNT           // global variable
  78:	e59f4214 	ldr	r4, [pc, #532]	; 294 <COUNT>
                STR     R4, [R5]            // light up the red lights
  7c:	e5854000 	str	r4, [r5]
				LDR     R4, HEX_CODE        // global variable
  80:	e59f421c 	ldr	r4, [pc, #540]	; 2a4 <HEX_CODE>
                STR     R4, [R6]            // show the time in format SS:DD
  84:	e5864000 	str	r4, [r6]
                
				B       LOOP              	// Endlessly loop
  88:	eafffffa 	b	78 <LOOP>

0000008c <CONFIG_PRIV_TIMER>:

/* Configure the MPCore private timer to create interrupts every 1/100 seconds */
CONFIG_PRIV_TIMER:                              
                LDR		R0, =0xFFFEC600		// A9 private timer address
  8c:	e59f0228 	ldr	r0, [pc, #552]	; 2bc <BIT_CODE+0x14>
				LDR		R1, =2000000		// 0.01 seconds on 200MHz clock
  90:	e59f1228 	ldr	r1, [pc, #552]	; 2c0 <BIT_CODE+0x18>
				STR		R1, [R0]
  94:	e5801000 	str	r1, [r0]
				MOV		R1, #0b111			// Start timer and set it to auto-reload
  98:	e3a01007 	mov	r1, #7
				STR		R1, [R0, #0x8]
  9c:	e5801008 	str	r1, [r0, #8]
                BX      LR     
  a0:	e12fff1e 	bx	lr

000000a4 <CONFIG_TIMER>:
				
/* Configure the Interval Timer to create interrupts at 0.25 second intervals */
CONFIG_TIMER:   LDR		R0, =0xFF202000		// FPGA timer base address
  a4:	e59f0218 	ldr	r0, [pc, #536]	; 2c4 <BIT_CODE+0x1c>
                LDR     R1, RATE			
  a8:	e59f11ec 	ldr	r1, [pc, #492]	; 29c <RATE>
				STR		R1, [R0, #8]		// Set lower bits of timer
  ac:	e5801008 	str	r1, [r0, #8]
				LSR		R1, #16
  b0:	e1a01821 	lsr	r1, r1, #16
				STR		R1, [R0, #12]		// Set upper bits of timer
  b4:	e580100c 	str	r1, [r0, #12]
				MOV     R1, #0b0111			// Control register bits
  b8:	e3a01007 	mov	r1, #7
				STR     R1, [R0, #4]		// Start timer, set auto-reload and enable interrupts
  bc:	e5801004 	str	r1, [r0, #4]
                BX      LR
  c0:	e12fff1e 	bx	lr

000000c4 <CONFIG_KEYS>:

/* Configure the pushbutton KEYS to generate interrupts */
CONFIG_KEYS:                                    
                LDR     R0, =0xFF200050		// KEY address
  c4:	e59f01fc 	ldr	r0, [pc, #508]	; 2c8 <BIT_CODE+0x20>
				MOV     R1, #0xF			// set interrupt mask bits
  c8:	e3a0100f 	mov	r1, #15
				STR     R1, [R0, #0x8]		// interrupt mask register (base + 8)
  cc:	e5801008 	str	r1, [r0, #8]
                BX      LR
  d0:	e12fff1e 	bx	lr

000000d4 <SERVICE_IRQ>:

/* Define the exception service routines */
SERVICE_IRQ:    PUSH    {R0-R7, LR}
  d4:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
				LDR     R4, =0xFFFEC100		// GIC CPU interface base address
  d8:	e59f41ec 	ldr	r4, [pc, #492]	; 2cc <BIT_CODE+0x24>
				LDR     R5, [R4, #0x0C]		// read the ICCIAR in the CPU interface
  dc:	e594500c 	ldr	r5, [r4, #12]

000000e0 <FPGA_IRQ1_HANDLER>:

FPGA_IRQ1_HANDLER:
				CMP		R5, #29				// check the interrupt ID
  e0:	e355001d 	cmp	r5, #29
				BEQ		PRIV_INTERRUPT
  e4:	0a000004 	beq	fc <PRIV_INTERRUPT>
				CMP     R5, #73
  e8:	e3550049 	cmp	r5, #73	; 0x49
				BEQ		KEY_INTERRUPT
  ec:	0a000004 	beq	104 <KEY_INTERRUPT>
				CMP		R5, #72
  f0:	e3550048 	cmp	r5, #72	; 0x48
				BEQ		CLK_INTERRUPT
  f4:	0a000004 	beq	10c <CLK_INTERRUPT>

000000f8 <UNEXPECTED>:

UNEXPECTED:     B     	UNEXPECTED			// if not recognized, stop here
  f8:	eafffffe 	b	f8 <UNEXPECTED>

000000fc <PRIV_INTERRUPT>:
PRIV_INTERRUPT:	BL		PRIV_TIMER_ISR
  fc:	eb000007 	bl	120 <PRIV_TIMER_ISR>
				B		EXIT_IRQ
 100:	ea000003 	b	114 <EXIT_IRQ>

00000104 <KEY_INTERRUPT>:
KEY_INTERRUPT:	BL      KEY_ISR
 104:	eb00002c 	bl	1bc <KEY_ISR>
				B		EXIT_IRQ
 108:	ea000001 	b	114 <EXIT_IRQ>

0000010c <CLK_INTERRUPT>:
CLK_INTERRUPT:	BL		TIMER_ISR
 10c:	eb000022 	bl	19c <TIMER_ISR>
				B		EXIT_IRQ
 110:	eaffffff 	b	114 <EXIT_IRQ>

00000114 <EXIT_IRQ>:

EXIT_IRQ:       STR     R5, [R4, #0x10]		// write to the End of Interrupt Register (ICCEOIR)
 114:	e5845010 	str	r5, [r4, #16]
				POP     {R0-R7, LR}
 118:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
				SUBS    PC, LR, #4			// return from exception
 11c:	e25ef004 	subs	pc, lr, #4

00000120 <PRIV_TIMER_ISR>:

/* Check if private timer generated an interrupt and increments time */
PRIV_TIMER_ISR:	LDR		R0, =0xFFFEC600		// base address of private timer
 120:	e59f0194 	ldr	r0, [pc, #404]	; 2bc <BIT_CODE+0x14>
				MOV		R1, #1
 124:	e3a01001 	mov	r1, #1
				STR		R1, [R0, #0xC] 		// clear the interrupt
 128:	e580100c 	str	r1, [r0, #12]
				LDR		R1, TIME			// Increment TIME
 12c:	e59f116c 	ldr	r1, [pc, #364]	; 2a0 <TIME>
				ADD		R1, #1
 130:	e2811001 	add	r1, r1, #1
				LDR		R2, =6000			// Load a literal
 134:	e59f2194 	ldr	r2, [pc, #404]	; 2d0 <BIT_CODE+0x28>
				CMP		R1, R2				// Wrap around to 0 when TIME > 5999
 138:	e1510002 	cmp	r1, r2
				BNE		SET_HEX
 13c:	1a000000 	bne	144 <SET_HEX>
				MOV		R1, #0
 140:	e3a01000 	mov	r1, #0

00000144 <SET_HEX>:

SET_HEX:		PUSH	{LR}
 144:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
				LDR		R3, =BIT_CODE
 148:	e59f3184 	ldr	r3, [pc, #388]	; 2d4 <BIT_CODE+0x2c>
				STR		R1, TIME			// Stores TIME
 14c:	e58f114c 	str	r1, [pc, #332]	; 2a0 <TIME>
				MOV		R0, R1				// Separate R1 into its digits
 150:	e1a00001 	mov	r0, r1
				BL		DIVIDE
 154:	eb000045 	bl	270 <DIVIDE>
				LDRB	R0, [R3, +R0]		// Get pattern for ones digit
 158:	e7d30000 	ldrb	r0, [r3, r0]
				MOV		R2, R0		
 15c:	e1a02000 	mov	r2, r0
				
				MOV		R0,	R1				// Get tens digit
 160:	e1a00001 	mov	r0, r1
				BL		DIVIDE
 164:	eb000041 	bl	270 <DIVIDE>
				LDRB	R0, [R3, +R0]		// Get pattern for tens digit
 168:	e7d30000 	ldrb	r0, [r3, r0]
				LSL		R0, #8
 16c:	e1a00400 	lsl	r0, r0, #8
				ORR		R2, R0
 170:	e1822000 	orr	r2, r2, r0
				
				MOV		R0, R1				// Get hundredth digit
 174:	e1a00001 	mov	r0, r1
				BL		DIVIDE				// Remainder from divide is thousandth digit
 178:	eb00003c 	bl	270 <DIVIDE>
				LDRB	R0, [R3, +R0]		// Get pattern for hundreds digit
 17c:	e7d30000 	ldrb	r0, [r3, r0]
				LSL		R0, #16
 180:	e1a00800 	lsl	r0, r0, #16
				ORR		R2, R0
 184:	e1822000 	orr	r2, r2, r0
				LDRB	R1, [R3, +R1]		// Get pattern for thousandth digit
 188:	e7d31001 	ldrb	r1, [r3, r1]
				LSL		R1, #24
 18c:	e1a01c01 	lsl	r1, r1, #24
				ORR		R2, R1
 190:	e1822001 	orr	r2, r2, r1
				
				STR		R2, HEX_CODE		// Set HEX_CODE for 7 segments
 194:	e58f2108 	str	r2, [pc, #264]	; 2a4 <HEX_CODE>

00000198 <END_PRIV_TIMER_ISR>:

END_PRIV_TIMER_ISR:	
				POP		{PC}				// Return
 198:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

0000019c <TIMER_ISR>:

/* Check if FPGA timer generated an interrupt and adds RUN to COUNT */
TIMER_ISR:		LDR     R0, =0xFF202000		// base address of FPGA timer
 19c:	e59f0120 	ldr	r0, [pc, #288]	; 2c4 <BIT_CODE+0x1c>
				MOV     R2, #0
 1a0:	e3a02000 	mov	r2, #0
				STR     R2, [R0]			// clear the interrupt
 1a4:	e5802000 	str	r2, [r0]
				LDR     R0, RUN				// Load RUN toggle
 1a8:	e59f00e8 	ldr	r0, [pc, #232]	; 298 <RUN>
				LDR		R1, COUNT			// Load counter
 1ac:	e59f10e0 	ldr	r1, [pc, #224]	; 294 <COUNT>
				ADD		R1, R0				// Increment counter by RUN
 1b0:	e0811000 	add	r1, r1, r0
				STR		R1, COUNT			// Store incremented counter
 1b4:	e58f10d8 	str	r1, [pc, #216]	; 294 <COUNT>

000001b8 <END_TIMER_ISR>:
END_TIMER_ISR:	BX		LR					// Return
 1b8:	e12fff1e 	bx	lr

000001bc <KEY_ISR>:
				
/* Check if a key has been pressed and toggles RUN */
KEY_ISR:		LDR     R0, =0xFF200050		// base address of pushbutton KEY port
 1bc:	e59f0104 	ldr	r0, [pc, #260]	; 2c8 <BIT_CODE+0x20>
				LDR     R1, [R0, #0xC]		// read edge capture register
 1c0:	e590100c 	ldr	r1, [r0, #12]
				MOV     R2, #0xF
 1c4:	e3a0200f 	mov	r2, #15
				STR     R2, [R0, #0xC]		// clear the interrupt
 1c8:	e580200c 	str	r2, [r0, #12]

000001cc <CHECK_KEY0>:

CHECK_KEY0:		MOV		R3, #0b0001
 1cc:	e3a03001 	mov	r3, #1
				CMP		R3, R1				// Check for KEY0
 1d0:	e1530001 	cmp	r3, r1
				BNE		CHECK_KEY1
 1d4:	1a000007 	bne	1f8 <CHECK_KEY1>
				LDR     R0, RUN				// LOAD RUN toggle
 1d8:	e59f00b8 	ldr	r0, [pc, #184]	; 298 <RUN>
				EOR		R0, #1				// Toggle RUN
 1dc:	e2200001 	eor	r0, r0, #1
				STR		R0, RUN				// Set RUN in memory
 1e0:	e58f00b0 	str	r0, [pc, #176]	; 298 <RUN>
				LDR		R0, =0xFFFEC600		// Load private timer
 1e4:	e59f00d0 	ldr	r0, [pc, #208]	; 2bc <BIT_CODE+0x14>
				LDR     R1, [R0, #0x8]		// Get timer control register
 1e8:	e5901008 	ldr	r1, [r0, #8]
				EOR		R1, #1				// Toggle RUN for private timer
 1ec:	e2211001 	eor	r1, r1, #1
				STR		R1, [R0, #0x8]		// Set timer control register
 1f0:	e5801008 	str	r1, [r0, #8]
				B		END_KEY_ISR
 1f4:	ea00001c 	b	26c <END_KEY_ISR>

000001f8 <CHECK_KEY1>:

CHECK_KEY1:		MOV		R3, #0b0010
 1f8:	e3a03002 	mov	r3, #2
				CMP		R3, R1				// Check for KEY1
 1fc:	e1530001 	cmp	r3, r1
				BNE		CHECK_KEY2
 200:	1a000008 	bne	228 <CHECK_KEY2>
				LDR     R0, =0xFF202000		// Address of FPGA timer
 204:	e59f00b8 	ldr	r0, [pc, #184]	; 2c4 <BIT_CODE+0x1c>
				MOV		R1, #0b1000
 208:	e3a01008 	mov	r1, #8
				STR		R1, [R0, #4]		// Stop timer
 20c:	e5801004 	str	r1, [r0, #4]
				LDR		R1, RATE
 210:	e59f1084 	ldr	r1, [pc, #132]	; 29c <RATE>
				LSR		R1, #1				// Double the rate (HALF the timeout)
 214:	e1a010a1 	lsr	r1, r1, #1
				CMP		R1, #0xFF				// Limit maximum rate
 218:	e35100ff 	cmp	r1, #255	; 0xff
				BGT		SET_TIMER
 21c:	ca00000c 	bgt	254 <SET_TIMER>
				MOV		R1, #0xFF
 220:	e3a010ff 	mov	r1, #255	; 0xff
				B		SET_TIMER
 224:	ea00000a 	b	254 <SET_TIMER>

00000228 <CHECK_KEY2>:
				
CHECK_KEY2:		MOV		R3, #0b0100
 228:	e3a03004 	mov	r3, #4
				CMP		R3, R1				// Check for KEY2
 22c:	e1530001 	cmp	r3, r1
				BNE		END_KEY_ISR
 230:	1a00000d 	bne	26c <END_KEY_ISR>
				LDR     R0, =0xFF202000		// Address of FPGA timer
 234:	e59f0088 	ldr	r0, [pc, #136]	; 2c4 <BIT_CODE+0x1c>
				MOV		R1, #0b1000
 238:	e3a01008 	mov	r1, #8
				STR		R1, [R0, #4]		// Stop timer
 23c:	e5801004 	str	r1, [r0, #4]
				LDR		R1, RATE
 240:	e59f1054 	ldr	r1, [pc, #84]	; 29c <RATE>
				LSL		R1, #1				// Half the rate (DOUBLE the timeout)
 244:	e1a01081 	lsl	r1, r1, #1
				CMP		R1, #0				// Limit minimum rate
 248:	e3510000 	cmp	r1, #0
				BNE		SET_TIMER
 24c:	1a000000 	bne	254 <SET_TIMER>
				MOV		R1, #0xA0000000
 250:	e3a0120a 	mov	r1, #-1610612736	; 0xa0000000

00000254 <SET_TIMER>:
				
SET_TIMER:		STR		R1, RATE			// Store the rate
 254:	e58f1040 	str	r1, [pc, #64]	; 29c <RATE>
				STR		R1, [R0, #8]		// Set lower bits of timer
 258:	e5801008 	str	r1, [r0, #8]
				LSR		R1, #16
 25c:	e1a01821 	lsr	r1, r1, #16
				STR		R1, [R0, #12]		// Set upper bits of timer
 260:	e580100c 	str	r1, [r0, #12]
				MOV     R1, #0b0111			// Control register bits
 264:	e3a01007 	mov	r1, #7
				STR     R1, [R0, #4]		// Start timer, set auto-reload and enable interrupts
 268:	e5801004 	str	r1, [r0, #4]

0000026c <END_KEY_ISR>:

END_KEY_ISR:	BX		LR					// Return
 26c:	e12fff1e 	bx	lr

00000270 <DIVIDE>:

/* Subroutine to perform the integer division R0 / 10.
 * Returns quotient in R1 and remainder in R0
 */
DIVIDE:     	PUSH	{R2,LR}
 270:	e92d4004 	push	{r2, lr}
				MOV     R2, #0
 274:	e3a02000 	mov	r2, #0

00000278 <CONT>:
CONT:       	CMP     R0, #10
 278:	e350000a 	cmp	r0, #10
				BLT     DIV_END
 27c:	ba000002 	blt	28c <DIV_END>
				SUB     R0, #10
 280:	e240000a 	sub	r0, r0, #10
				ADD     R2, #1
 284:	e2822001 	add	r2, r2, #1
				B       CONT
 288:	eafffffa 	b	278 <CONT>

0000028c <DIV_END>:
DIV_END:    	MOV     R1, R2     			// quotient in R1 (remainder in R0)
 28c:	e1a01002 	mov	r1, r2
				POP     {R2,PC}
 290:	e8bd8004 	pop	{r2, pc}

00000294 <COUNT>:
 294:	00000000 	.word	0x00000000

00000298 <RUN>:
 298:	00000001 	.word	0x00000001

0000029c <RATE>:
 29c:	017d7840 	.word	0x017d7840

000002a0 <TIME>:
 2a0:	00000000 	.word	0x00000000

000002a4 <HEX_CODE>:
 2a4:	00000000 	.word	0x00000000

000002a8 <BIT_CODE>:
 2a8:	4f5b063f 	.word	0x4f5b063f
 2ac:	077d6d66 	.word	0x077d6d66
 2b0:	0000677f 	.word	0x0000677f
 2b4:	ff200000 	.word	0xff200000
 2b8:	ff200020 	.word	0xff200020
 2bc:	fffec600 	.word	0xfffec600
 2c0:	001e8480 	.word	0x001e8480
 2c4:	ff202000 	.word	0xff202000
 2c8:	ff200050 	.word	0xff200050
 2cc:	fffec100 	.word	0xfffec100
 2d0:	00001770 	.word	0x00001770
 2d4:	000002a8 	.word	0x000002a8

000002d8 <CONFIG_GIC>:
/* 
 * Configure the Generic Interrupt Controller (GIC)
*/
				.global	CONFIG_GIC
CONFIG_GIC:
				PUSH		{LR}
 2d8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    			/* Configure the A9 Private Timer interrupt, FPGA KEYs, and FPGA Timer
				/* CONFIG_INTERRUPT (int_ID (R0), CPU_target (R1)); */
    			MOV		R0, #MPCORE_PRIV_TIMER_IRQ
 2dc:	e3a0001d 	mov	r0, #29
    			MOV		R1, #CPU0
 2e0:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 2e4:	eb00000d 	bl	320 <CONFIG_INTERRUPT>
    			MOV		R0, #INTERVAL_TIMER_IRQ
 2e8:	e3a00048 	mov	r0, #72	; 0x48
    			MOV		R1, #CPU0
 2ec:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 2f0:	eb00000a 	bl	320 <CONFIG_INTERRUPT>
    			MOV		R0, #KEYS_IRQ
 2f4:	e3a00049 	mov	r0, #73	; 0x49
    			MOV		R1, #CPU0
 2f8:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 2fc:	eb000007 	bl	320 <CONFIG_INTERRUPT>

				/* configure the GIC CPU interface */
    			LDR		R0, =0xFFFEC100		// base address of CPU interface
 300:	e59f0060 	ldr	r0, [pc, #96]	; 368 <__cs3_region_init_size_ram>
    			/* Set Interrupt Priority Mask Register (ICCPMR) */
    			LDR		R1, =0xFFFF 			// enable interrupts of all priorities levels
 304:	e59f1060 	ldr	r1, [pc, #96]	; 36c <__cs3_region_init_size_ram+0x4>
    			STR		R1, [R0, #0x04]
 308:	e5801004 	str	r1, [r0, #4]
    			/* Set the enable bit in the CPU Interface Control Register (ICCICR). This bit
				 * allows interrupts to be forwarded to the CPU(s) */
    			MOV		R1, #1
 30c:	e3a01001 	mov	r1, #1
    			STR		R1, [R0]
 310:	e5801000 	str	r1, [r0]
    
    			/* Set the enable bit in the Distributor Control Register (ICDDCR). This bit
				 * allows the distributor to forward interrupts to the CPU interface(s) */
    			LDR		R0, =0xFFFED000
 314:	e59f0054 	ldr	r0, [pc, #84]	; 370 <__cs3_region_init_size_ram+0x8>
    			STR		R1, [R0]    
 318:	e5801000 	str	r1, [r0]
    
    			POP     	{PC}
 31c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00000320 <CONFIG_INTERRUPT>:
 * other registers in the GIC
 * Arguments: R0 = interrupt ID, N
 *            R1 = CPU target
*/
CONFIG_INTERRUPT:
    			PUSH		{R4-R5, LR}
 320:	e92d4030 	push	{r4, r5, lr}
    
    			/* Configure Interrupt Set-Enable Registers (ICDISERn). 
				 * reg_offset = (integer_div(N / 32) * 4
				 * value = 1 << (N mod 32) */
    			LSR		R4, R0, #3							// calculate reg_offset
 324:	e1a041a0 	lsr	r4, r0, #3
    			BIC		R4, R4, #3							// R4 = reg_offset
 328:	e3c44003 	bic	r4, r4, #3
				LDR		R2, =0xFFFED100
 32c:	e59f2040 	ldr	r2, [pc, #64]	; 374 <__cs3_region_init_size_ram+0xc>
				ADD		R4, R2, R4							// R4 = address of ICDISER
 330:	e0824004 	add	r4, r2, r4
    
    			AND		R2, R0, #0x1F   					// N mod 32
 334:	e200201f 	and	r2, r0, #31
				MOV		R5, #1								// enable
 338:	e3a05001 	mov	r5, #1
    			LSL		R2, R5, R2							// R2 = value
 33c:	e1a02215 	lsl	r2, r5, r2

				/* now that we have the register address (R4) and value (R2), we need to set the
				 * correct bit in the GIC register */
    			LDR		R3, [R4]								// read current register value
 340:	e5943000 	ldr	r3, [r4]
    			ORR		R3, R3, R2							// set the enable bit
 344:	e1833002 	orr	r3, r3, r2
    			STR		R3, [R4]								// store the new register value
 348:	e5843000 	str	r3, [r4]

    			/* Configure Interrupt Processor Targets Register (ICDIPTRn)
     			 * reg_offset = integer_div(N / 4) * 4
     			 * index = N mod 4 */
    			BIC		R4, R0, #3							// R4 = reg_offset
 34c:	e3c04003 	bic	r4, r0, #3
				LDR		R2, =0xFFFED800
 350:	e59f2020 	ldr	r2, [pc, #32]	; 378 <__cs3_region_init_size_ram+0x10>
				ADD		R4, R2, R4							// R4 = word address of ICDIPTR
 354:	e0824004 	add	r4, r2, r4
    			AND		R2, R0, #0x3						// N mod 4
 358:	e2002003 	and	r2, r0, #3
				ADD		R4, R2, R4							// R4 = byte address in ICDIPTR
 35c:	e0824004 	add	r4, r2, r4

				/* now that we have the register address (R4) and value (R2), write to (only)
				 * the appropriate byte */
				STRB		R1, [R4]
 360:	e5c41000 	strb	r1, [r4]
    
    			POP		{R4-R5, PC}
 364:	e8bd8030 	pop	{r4, r5, pc}
 368:	fffec100 	.word	0xfffec100
 36c:	0000ffff 	.word	0x0000ffff
 370:	fffed000 	.word	0xfffed000
 374:	fffed100 	.word	0xfffed100
 378:	fffed800 	.word	0xfffed800

0000037c <SERVICE_UND>:
/* Undefined instructions */
					.global SERVICE_UND
SERVICE_UND:                                
                    B   SERVICE_UND         
 37c:	eafffffe 	b	37c <SERVICE_UND>

00000380 <SERVICE_SVC>:
/* Software interrupts */
					.global SERVICE_SVC
SERVICE_SVC:                                
                    B   SERVICE_SVC         
 380:	eafffffe 	b	380 <SERVICE_SVC>

00000384 <SERVICE_ABT_DATA>:
/* Aborted data reads */
					.global SERVICE_ABT_DATA
SERVICE_ABT_DATA:                           
                    B   SERVICE_ABT_DATA    
 384:	eafffffe 	b	384 <SERVICE_ABT_DATA>

00000388 <SERVICE_ABT_INST>:
/* Aborted instruction fetch */
					.global SERVICE_ABT_INST
SERVICE_ABT_INST:                           
                    B   SERVICE_ABT_INST   
 388:	eafffffe 	b	388 <SERVICE_ABT_INST>

0000038c <SERVICE_FIQ>:
					.global SERVICE_FIQ 
SERVICE_FIQ:                                
                    B   SERVICE_FIQ         
 38c:	eafffffe 	b	38c <SERVICE_FIQ>
