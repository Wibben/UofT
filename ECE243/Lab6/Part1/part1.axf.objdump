
W:/ECE243/Lab6/Part1/part1.axf:     file format elf32-littlearm


Disassembly of section .vectors:

00000000 <__cs3_interrupt_vector>:
   0:	ea00000e 	b	40 <__cs3_region_init_ram>
   4:	ea000085 	b	220 <SERVICE_UND>
   8:	ea000085 	b	224 <SERVICE_SVC>
   c:	ea000086 	b	22c <SERVICE_ABT_INST>
  10:	ea000084 	b	228 <SERVICE_ABT_DATA>
  14:	00000000 	.word	0x00000000
  18:	ea000018 	b	80 <SERVICE_IRQ>
  1c:	ea000083 	b	230 <SERVICE_FIQ>

Disassembly of section .text:

00000040 <__cs3_region_start_ram>:
				B       SERVICE_IRQ			// IRQ interrupt vector
				B       SERVICE_FIQ			// FIQ interrupt vector
				.text
				.global _start
/* Set up stack pointers for IRQ and SVC processor modes */
_start:			LDR		R0, =0xFF200020		// based address of HEX display
  40:	e59f0128 	ldr	r0, [pc, #296]	; 170 <END_KEY_ISR+0x4>
				MOV		R1, #0
  44:	e3a01000 	mov	r1, #0
				STR		R1, [R0]
  48:	e5801000 	str	r1, [r0]

				MOV     R1, #0b11010010		// interrupts masked, MODE = IRQ
  4c:	e3a010d2 	mov	r1, #210	; 0xd2
				MSR		CPSR_c, R1			// change to IRQ mode
  50:	e121f001 	msr	CPSR_c, r1
				LDR		SP, =0xFFFFFFFF - 3	// set IRQ stack to A9 onchip memory
  54:	e3e0d003 	mvn	sp, #3

				MOV     R1, #0b11010011		// interrupts masked, MODE = SVC
  58:	e3a010d3 	mov	r1, #211	; 0xd3
				MSR     CPSR, R1			// change to supervisor mode
  5c:	e129f001 	msr	CPSR_fc, r1
				LDR		SP, =0x3FFFFFFF - 3	// set SVC stack to top of DDR3 memory
  60:	e3e0d10f 	mvn	sp, #-1073741821	; 0xc0000003
				
				BL      CONFIG_GIC			// configure the ARM generic interrupt controller
  64:	eb000044 	bl	17c <CONFIG_GIC>

/* Configure the KEY pushbuttons port to generate interrupts */
				LDR     R0, =0xFF200050		// KEY address
  68:	e59f0104 	ldr	r0, [pc, #260]	; 174 <END_KEY_ISR+0x8>
				MOV     R1, #0xF			// set interrupt mask bits
  6c:	e3a0100f 	mov	r1, #15
				STR     R1, [R0, #0x8]		// interrupt mask register (base + 8)
  70:	e5801008 	str	r1, [r0, #8]

/* Enable IRQ interrupts in the ARM processor */
				MOV      R0, #0b01010011	// IRQ unmasked, MODE = SVC
  74:	e3a00053 	mov	r0, #83	; 0x53
				MSR      CPSR_c, R0
  78:	e121f000 	msr	CPSR_c, r0

0000007c <IDLE>:

IDLE:			B       IDLE				// main program simply idles
  7c:	eafffffe 	b	7c <IDLE>

00000080 <SERVICE_IRQ>:

/* Define the exception service routines */
SERVICE_IRQ:    PUSH    {R0-R7, LR}
  80:	e92d40ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
				LDR     R4, =0xFFFEC100		// GIC CPU interface base address
  84:	e59f40ec 	ldr	r4, [pc, #236]	; 178 <END_KEY_ISR+0xc>
				LDR     R5, [R4, #0x0C]		// read the ICCIAR in the CPU interface
  88:	e594500c 	ldr	r5, [r4, #12]

0000008c <FPGA_IRQ1_HANDLER>:

FPGA_IRQ1_HANDLER:
				CMP     R5, #73				// check the interrupt ID
  8c:	e3550049 	cmp	r5, #73	; 0x49

00000090 <UNEXPECTED>:

UNEXPECTED:     BNE     UNEXPECTED			// if not recognized, stop here
  90:	1afffffe 	bne	90 <UNEXPECTED>
				BL      KEY_ISR
  94:	eb000002 	bl	a4 <KEY_ISR>

00000098 <EXIT_IRQ>:

EXIT_IRQ:       STR     R5, [R4, #0x10]		// write to the End of Interrupt Register (ICCEOIR)
  98:	e5845010 	str	r5, [r4, #16]
				POP     {R0-R7, LR}
  9c:	e8bd40ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
				SUBS    PC, LR, #4			// return from exception
  a0:	e25ef004 	subs	pc, lr, #4

000000a4 <KEY_ISR>:

/* Check which key has been pressed and writes accordingly */
KEY_ISR:		LDR     R0, =0xFF200050		// base address of pushbutton KEY port
  a4:	e59f00c8 	ldr	r0, [pc, #200]	; 174 <END_KEY_ISR+0x8>
				LDR     R1, [R0, #0xC]		// read edge capture register
  a8:	e590100c 	ldr	r1, [r0, #12]
				MOV     R2, #0xF
  ac:	e3a0200f 	mov	r2, #15
				STR     R2, [R0, #0xC]		// clear the interrupt
  b0:	e580200c 	str	r2, [r0, #12]
				LDR     R0, =0xFF200020		// based address of HEX display
  b4:	e59f00b4 	ldr	r0, [pc, #180]	; 170 <END_KEY_ISR+0x4>

000000b8 <CHECK_KEY0>:

CHECK_KEY0:		MOV		R3, #0b0001
  b8:	e3a03001 	mov	r3, #1
				CMP		R3, R1				// Check for KEY0
  bc:	e1530001 	cmp	r3, r1
				BNE		CHECK_KEY1
  c0:	1a000008 	bne	e8 <CHECK_KEY1>
				MOV		R2, #0b00111111		// '0'
  c4:	e3a0203f 	mov	r2, #63	; 0x3f
				LDRB	R3, [R0]			// HEX0
  c8:	e5d03000 	ldrb	r3, [r0]
				CMP		R2, R3
  cc:	e1520003 	cmp	r2, r3
				BEQ		CLEAR_HEX0			// Check is HEX0 is already '0'
  d0:	0a000001 	beq	dc <CLEAR_HEX0>
				STRB	R2, [R0]			// Display '0'
  d4:	e5c02000 	strb	r2, [r0]
				B		END_KEY_ISR
  d8:	ea000023 	b	16c <END_KEY_ISR>

000000dc <CLEAR_HEX0>:
CLEAR_HEX0:		MOV		R2, #0
  dc:	e3a02000 	mov	r2, #0
				STRB	R2, [R0]			// Display blank
  e0:	e5c02000 	strb	r2, [r0]
				B		END_KEY_ISR
  e4:	ea000020 	b	16c <END_KEY_ISR>

000000e8 <CHECK_KEY1>:

CHECK_KEY1:		MOV		R3, #0b0010
  e8:	e3a03002 	mov	r3, #2
				CMP		R3, R1				// Check for KEY1
  ec:	e1530001 	cmp	r3, r1
				BNE		CHECK_KEY2
  f0:	1a000008 	bne	118 <CHECK_KEY2>
				MOV		R2, #0b00000110		// '1'
  f4:	e3a02006 	mov	r2, #6
				LDRB	R3, [R0, #1]		// HEX1
  f8:	e5d03001 	ldrb	r3, [r0, #1]
				CMP		R2, R3
  fc:	e1520003 	cmp	r2, r3
				BEQ		CLEAR_HEX1			// Check is HEX1 is already '1'
 100:	0a000001 	beq	10c <CLEAR_HEX1>
				STRB	R2, [R0, #1]		// Display '1'
 104:	e5c02001 	strb	r2, [r0, #1]
				B		END_KEY_ISR
 108:	ea000017 	b	16c <END_KEY_ISR>

0000010c <CLEAR_HEX1>:
CLEAR_HEX1:		MOV		R2, #0
 10c:	e3a02000 	mov	r2, #0
				STRB	R2, [R0, #1]		// Display blank
 110:	e5c02001 	strb	r2, [r0, #1]
				B		END_KEY_ISR
 114:	ea000014 	b	16c <END_KEY_ISR>

00000118 <CHECK_KEY2>:

CHECK_KEY2:		MOV		R3, #0b0100
 118:	e3a03004 	mov	r3, #4
				CMP		R3, R1				// Check for KEY2
 11c:	e1530001 	cmp	r3, r1
				BNE		IS_KEY3
 120:	1a000008 	bne	148 <IS_KEY3>
				MOV		R2, #0b01011011		// '2'
 124:	e3a0205b 	mov	r2, #91	; 0x5b
				LDRB	R3, [R0, #2]		// HEX2
 128:	e5d03002 	ldrb	r3, [r0, #2]
				CMP		R2, R3
 12c:	e1520003 	cmp	r2, r3
				BEQ		CLEAR_HEX2			// Check is HEX2 is already '2'
 130:	0a000001 	beq	13c <CLEAR_HEX2>
				STRB	R2, [R0, #2]		// Display '2'
 134:	e5c02002 	strb	r2, [r0, #2]
				B		END_KEY_ISR
 138:	ea00000b 	b	16c <END_KEY_ISR>

0000013c <CLEAR_HEX2>:
CLEAR_HEX2:		MOV		R2, #0
 13c:	e3a02000 	mov	r2, #0
				STRB	R2, [R0, #2]		// Display blank
 140:	e5c02002 	strb	r2, [r0, #2]
				B		END_KEY_ISR
 144:	ea000008 	b	16c <END_KEY_ISR>

00000148 <IS_KEY3>:

IS_KEY3:		MOV		R2, #0b01001111		// '3'
 148:	e3a0204f 	mov	r2, #79	; 0x4f
				LDRB	R3, [R0, #3]		// HEX3
 14c:	e5d03003 	ldrb	r3, [r0, #3]
				CMP		R2, R3
 150:	e1520003 	cmp	r2, r3
				BEQ		CLEAR_HEX3			// Check is HEX3 is already '3'
 154:	0a000001 	beq	160 <CLEAR_HEX3>
				STRB	R2, [R0, #3]		// Display '3'
 158:	e5c02003 	strb	r2, [r0, #3]
				B		END_KEY_ISR
 15c:	ea000002 	b	16c <END_KEY_ISR>

00000160 <CLEAR_HEX3>:
CLEAR_HEX3:		MOV		R2, #0
 160:	e3a02000 	mov	r2, #0
				STRB	R2, [R0, #3]		// Display blank
 164:	e5c02003 	strb	r2, [r0, #3]
				B		END_KEY_ISR
 168:	eaffffff 	b	16c <END_KEY_ISR>

0000016c <END_KEY_ISR>:
				
END_KEY_ISR:	BX		LR					// Return
 16c:	e12fff1e 	bx	lr
 170:	ff200020 	.word	0xff200020
 174:	ff200050 	.word	0xff200050
 178:	fffec100 	.word	0xfffec100

0000017c <CONFIG_GIC>:
/* 
 * Configure the Generic Interrupt Controller (GIC)
*/
				.global	CONFIG_GIC
CONFIG_GIC:
				PUSH		{LR}
 17c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    			/* Configure the A9 Private Timer interrupt, FPGA KEYs, and FPGA Timer
				/* CONFIG_INTERRUPT (int_ID (R0), CPU_target (R1)); */
    			MOV		R0, #MPCORE_PRIV_TIMER_IRQ
 180:	e3a0001d 	mov	r0, #29
    			MOV		R1, #CPU0
 184:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 188:	eb00000d 	bl	1c4 <CONFIG_INTERRUPT>
    			MOV		R0, #INTERVAL_TIMER_IRQ
 18c:	e3a00048 	mov	r0, #72	; 0x48
    			MOV		R1, #CPU0
 190:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 194:	eb00000a 	bl	1c4 <CONFIG_INTERRUPT>
    			MOV		R0, #KEYS_IRQ
 198:	e3a00049 	mov	r0, #73	; 0x49
    			MOV		R1, #CPU0
 19c:	e3a01001 	mov	r1, #1
    			BL			CONFIG_INTERRUPT
 1a0:	eb000007 	bl	1c4 <CONFIG_INTERRUPT>

				/* configure the GIC CPU interface */
    			LDR		R0, =0xFFFEC100		// base address of CPU interface
 1a4:	e59f0060 	ldr	r0, [pc, #96]	; 20c <__cs3_region_init_size_ram+0x4>
    			/* Set Interrupt Priority Mask Register (ICCPMR) */
    			LDR		R1, =0xFFFF 			// enable interrupts of all priorities levels
 1a8:	e59f1060 	ldr	r1, [pc, #96]	; 210 <__cs3_region_init_size_ram+0x8>
    			STR		R1, [R0, #0x04]
 1ac:	e5801004 	str	r1, [r0, #4]
    			/* Set the enable bit in the CPU Interface Control Register (ICCICR). This bit
				 * allows interrupts to be forwarded to the CPU(s) */
    			MOV		R1, #1
 1b0:	e3a01001 	mov	r1, #1
    			STR		R1, [R0]
 1b4:	e5801000 	str	r1, [r0]
    
    			/* Set the enable bit in the Distributor Control Register (ICDDCR). This bit
				 * allows the distributor to forward interrupts to the CPU interface(s) */
    			LDR		R0, =0xFFFED000
 1b8:	e59f0054 	ldr	r0, [pc, #84]	; 214 <__cs3_region_init_size_ram+0xc>
    			STR		R1, [R0]    
 1bc:	e5801000 	str	r1, [r0]
    
    			POP     	{PC}
 1c0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

000001c4 <CONFIG_INTERRUPT>:
 * other registers in the GIC
 * Arguments: R0 = interrupt ID, N
 *            R1 = CPU target
*/
CONFIG_INTERRUPT:
    			PUSH		{R4-R5, LR}
 1c4:	e92d4030 	push	{r4, r5, lr}
    
    			/* Configure Interrupt Set-Enable Registers (ICDISERn). 
				 * reg_offset = (integer_div(N / 32) * 4
				 * value = 1 << (N mod 32) */
    			LSR		R4, R0, #3							// calculate reg_offset
 1c8:	e1a041a0 	lsr	r4, r0, #3
    			BIC		R4, R4, #3							// R4 = reg_offset
 1cc:	e3c44003 	bic	r4, r4, #3
				LDR		R2, =0xFFFED100
 1d0:	e59f2040 	ldr	r2, [pc, #64]	; 218 <__cs3_region_init_size_ram+0x10>
				ADD		R4, R2, R4							// R4 = address of ICDISER
 1d4:	e0824004 	add	r4, r2, r4
    
    			AND		R2, R0, #0x1F   					// N mod 32
 1d8:	e200201f 	and	r2, r0, #31
				MOV		R5, #1								// enable
 1dc:	e3a05001 	mov	r5, #1
    			LSL		R2, R5, R2							// R2 = value
 1e0:	e1a02215 	lsl	r2, r5, r2

				/* now that we have the register address (R4) and value (R2), we need to set the
				 * correct bit in the GIC register */
    			LDR		R3, [R4]								// read current register value
 1e4:	e5943000 	ldr	r3, [r4]
    			ORR		R3, R3, R2							// set the enable bit
 1e8:	e1833002 	orr	r3, r3, r2
    			STR		R3, [R4]								// store the new register value
 1ec:	e5843000 	str	r3, [r4]

    			/* Configure Interrupt Processor Targets Register (ICDIPTRn)
     			 * reg_offset = integer_div(N / 4) * 4
     			 * index = N mod 4 */
    			BIC		R4, R0, #3							// R4 = reg_offset
 1f0:	e3c04003 	bic	r4, r0, #3
				LDR		R2, =0xFFFED800
 1f4:	e59f2020 	ldr	r2, [pc, #32]	; 21c <__cs3_region_init_size_ram+0x14>
				ADD		R4, R2, R4							// R4 = word address of ICDIPTR
 1f8:	e0824004 	add	r4, r2, r4
    			AND		R2, R0, #0x3						// N mod 4
 1fc:	e2002003 	and	r2, r0, #3
				ADD		R4, R2, R4							// R4 = byte address in ICDIPTR
 200:	e0824004 	add	r4, r2, r4

				/* now that we have the register address (R4) and value (R2), write to (only)
				 * the appropriate byte */
				STRB		R1, [R4]
 204:	e5c41000 	strb	r1, [r4]
    
    			POP		{R4-R5, PC}
 208:	e8bd8030 	pop	{r4, r5, pc}
 20c:	fffec100 	.word	0xfffec100
 210:	0000ffff 	.word	0x0000ffff
 214:	fffed000 	.word	0xfffed000
 218:	fffed100 	.word	0xfffed100
 21c:	fffed800 	.word	0xfffed800

00000220 <SERVICE_UND>:
/* Undefined instructions */
					.global SERVICE_UND
SERVICE_UND:                                
                    B   SERVICE_UND         
 220:	eafffffe 	b	220 <SERVICE_UND>

00000224 <SERVICE_SVC>:
/* Software interrupts */
					.global SERVICE_SVC
SERVICE_SVC:                                
                    B   SERVICE_SVC         
 224:	eafffffe 	b	224 <SERVICE_SVC>

00000228 <SERVICE_ABT_DATA>:
/* Aborted data reads */
					.global SERVICE_ABT_DATA
SERVICE_ABT_DATA:                           
                    B   SERVICE_ABT_DATA    
 228:	eafffffe 	b	228 <SERVICE_ABT_DATA>

0000022c <SERVICE_ABT_INST>:
/* Aborted instruction fetch */
					.global SERVICE_ABT_INST
SERVICE_ABT_INST:                           
                    B   SERVICE_ABT_INST   
 22c:	eafffffe 	b	22c <SERVICE_ABT_INST>

00000230 <SERVICE_FIQ>:
					.global SERVICE_FIQ 
SERVICE_FIQ:                                
                    B   SERVICE_FIQ
 230:	eafffffe 	b	230 <SERVICE_FIQ>
